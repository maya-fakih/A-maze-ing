FUNCTION generate_maze(width, height):
    # Initialize all cells with all walls (0b1111 = 15)
    maze = 2D array of size [height][width] all set to 15
    
    # Mark all cells as not visited
    visited = 2D array of size [height][width] all set to False
    
    # Start with random cell
    start_x = random(0, width-1)
    start_y = random(0, height-1)
    
    visited[start_y][start_x] = True
    
    # Create frontier list (neighbors of visited cells)
    frontier = []
    ADD neighbors of (start_x, start_y) to frontier with direction info
    
    WHILE frontier is not empty:
        # Pick random frontier cell
        (x, y, from_dir) = RANDOM cell from frontier
        REMOVE (x, y, from_dir) from frontier
        
        # Mark as visited
        visited[y][x] = True
        
        # Find which visited neighbor connected us
        # from_dir tells us which direction we came from
        # Example: if from_dir = "N", then we came from cell at (x, y-1)
        
        # Remove wall between current cell and neighbor
        IF from_dir == "N":
            # Current cell at (x,y) is SOUTH of neighbor at (x,y-1)
            maze[y][x] = maze[y][x] & ~NORTH    # Remove North wall from current
            maze[y-1][x] = maze[y-1][x] & ~SOUTH  # Remove South wall from neighbor
            
        ELSE IF from_dir == "S":
            maze[y][x] = maze[y][x] & ~SOUTH
            maze[y+1][x] = maze[y+1][x] & ~NORTH
            
        ELSE IF from_dir == "E":
            maze[y][x] = maze[y][x] & ~EAST
            maze[y][x+1] = maze[y][x+1] & ~WEST
            
        ELSE IF from_dir == "W":
            maze[y][x] = maze[y][x] & ~WEST
            maze[y][x-1] = maze[y][x-1] & ~EAST
        
        # Add new frontier cells (unvisited neighbors of current cell)
        FOR each direction in [N, S, E, W]:
            (nx, ny) = neighbor in that direction
            IF nx, ny are within bounds AND NOT visited[ny][nx]:
                ADD (nx, ny, opposite_direction) to frontier
                # opposite_direction because when we come back to this
                # cell from frontier, we need to know which wall to remove
    
    RETURN maze






BETTER PLAN! 


1. Initial Setup at Start of generate():
Initialize self.maze as 2D grid with all walls (value 15)

Initialize self.path as empty list

Re-add logo cells to maze (since you reinitialized)

2. Phase 1 Variables You'll Need:
solution_path = list of cells from entry to exit

visited = set of cells already processed (starts with entry + logo cells)

Maybe current_cell to track position

3. Phase 2 Variables:
frontier = list/stack for LIFO expansion

Continue using visited set

4. Key Helper Functions to Think About:
A. get_neighbors(cell) - returns list of (neighbor, direction) within bounds, not logo cells

B. manhattan_distance(cell1, cell2) - for checking if moving toward exit

C. get_valid_moves_from(cell) - returns moves that:

Have a wall between cells

Neighbor not visited

Move toward exit (or at least not away)

5. The "Last 3 Cells" Strategy:
When stuck at position in Phase 1:

Look at solution_path[-3:] (last 3 cells)

For each, check get_valid_moves_from(cell)

Pick one with moves available

If none have moves, maybe expand to last 5?

6. Adding to self.path:
After each successful wall removal:

self.path.append((new_cell, maze_value, is_solution_bool))

is_solution_bool = True for Phase 1 cells

is_solution_bool = False for Phase 2 cells